" 
layout(location = 0) in vec3 model_vertexpos;
layout(location = 2) in vec2 decal_uv;
layout(location = 1) in vec2 light_uv;
layout(location = 3) in vec3 model_normalpos;

out vec2 decal_pos;
out vec2 light_pos;

uniform mat4 ModelMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 ViewMatrix;

out vec4 ModelViewMatrix;
out vec3 NormalizedNormal;
out vec3 worldPos;

void main() { 
   
    decal_pos = decal_uv;
    light_pos = light_uv;
    
    ModelViewMatrix = ModelMatrix * vec4(model_vertexpos, 1.0);
	NormalizedNormal = vec3(1.0);
	worldPos = vec3(ModelViewMatrix*vec4(model_vertexpos, 1.0));
	
    mat4 mvp = ProjectionMatrix * ViewMatrix * ModelMatrix;
    gl_Position = mvp * vec4(model_vertexpos, 1.0);
}

"

uniform sampler2D decalMap;    // Level textures.
uniform sampler2D lightMap;    // Level light map.
uniform sampler2D normalMap;   // Level decal normal map.

uniform sampler2D depthMap;	

struct Light {
	vec3 diffuse;
	vec3 position;
	float dotSize;
};
uniform Light lights[3];

uniform vec3 cameraPos;

in vec2 decal_pos;      
in vec2 light_pos;

layout(location = 0) out vec4 color;

in vec4 ModelViewMatrix;
in vec3 NormalizedNormal;
in vec3 worldPos;

#define PI  3.14159265

float scatterAmount = 0.06;

float atanR(float x) {
   return PI*0.5*x / (1.0+x);
}

float Scatter(vec3 vPos, vec3 lPos, float dotSize) {
	float d = length(vPos/dotSize);
	vPos /= d;

	vec3 q = -lPos;

	float b = dot(vPos, q);
	float c = dot(q, q);

	float s = 1.0/sqrt(c-b*b);

	float l = s*(atan((d+b)*s)-atan(b*s));

	return l;
}

vec3 LinearToSrgb(vec3 rgb) {
	return pow(rgb, vec3(1.0/2.2));
}

float phong(vec3 worldPos, vec3 normal, vec3 lightPos, float spec) {
	vec3 l = lightPos-worldPos;
	float d = length(l);
	l /= d;

	vec3 h = normalize(l);
	
	float diffuse = clamp(dot(normal, l),0.0,1.0) / (d*d*2.0);
	float specular = pow(clamp(dot(h,normal),0.0,1.0), spec)/ (d);
    return diffuse+(specular);
}

void main() {
	vec3 worldPos = ModelViewMatrix.xyz;
    vec3 normalPos = NormalizedNormal.xyz;

	vec3 ct, cf, c;
  	vec4 texel;
  	
  	float intensity, at, af, a;
  	vec3 lightDir = vec3(0.0f);
  	vec3 normal = vec3(0.0f);
  	
  	intensity = -0.5f;

	vec3 l = worldPos;
	float d = length(l / 100.0);
	l /= d;

    vec3 scatter = vec3(0.0);
    vec3 light = vec3(0.0);
    
	float coefA = smoothstep( 1.0, 0.2, intensity );

    for( int i = 0; i < 3; i++ ) {
    	vec3 lightPos = lights[i].position;
    	vec3 lightDiff = lights[i].diffuse;
     	scatter += lightDiff * ( vec3(0.2, 0.5, 0.8) * 40.5 + 1.8 ) * Scatter(worldPos, lightPos, 1.0);
   
       	vec3 ls = worldPos / 70.0;
    	float atten = 1.0 - dot(ls, ls);
   
     	light += coefA * lightDiff * phong(worldPos, normalPos, lightPos, 0.5) * atten;
  	}
  	
  	light += coefA * vec3(texture(lightMap, light_pos));

  	cf = vec3( intensity );

	texel = texture(decalMap, decal_pos);
  	
 	ct = texel.rgb;
  	at = texel.a;

  	c = cf * ct;
  	a = at;  
  
  	float fog = clamp( 25.0, 0.0, 1.0 );
  	float coef = smoothstep( 1.0, 0.2, -0.5 );

  	c += coef * vec3(texture(lightMap, light_pos));
	
    vec3 _normal = texture(normalMap, decal_pos).rgb;

    vec3 N = normalize(_normal * 2.0 - 1.0);
    vec3 L = normalize(light);


    vec3 Diffuse = (c * a) * max(dot(N, L), 0.0);

	float nDotL = dot(N, L);
	vec3 normalVector = vec3(_normal - vec3(0.5));
 	normalVector = normalize(normalVector);
  
	vec3 reflection = normalVector;
    reflection = reflection * nDotL * 2.0;
    reflection -= L;
    float specIntensity = pow( dot( reflection, vec3(0.0, 0.0, 1.0) ), 40.6);

	//Diffuse += finalSpec;
    float fogA = clamp( distance(worldPos, cameraPos) / 2500.0, 0.0, 1.0 );
    

	vec3 scatter_decal = (vec3(texture(decalMap, decal_pos)) + specIntensity) / 2.5;
	scatter += specIntensity;
    vec3 lights = mix( ( Diffuse * (light + specIntensity) ) + (scatter+scatter_decal) * 0.1, 0.1 + (scatter+scatter_decal) * 0.1, fogA );

    color.rgb = lights;
    color.a = 1.0;
}
"