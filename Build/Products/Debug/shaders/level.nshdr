" 
layout(location = 0) in vec3 model_vertexpos;
layout(location = 2) in vec2 decal_uv;
layout(location = 1) in vec2 light_uv;
layout(location = 3) in vec3 model_normalpos;

out vec2 decal_pos;
out vec2 light_pos;

uniform mat4 ModelMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 ViewMatrix;

out vec4 ModelViewMatrix;
out vec3 NormalizedNormal;
out vec3 worldPos;
out vec3 Normal0;  

void main() { 
   
    decal_pos = decal_uv;
    light_pos = light_uv;
    
    ModelViewMatrix = ModelMatrix * vec4(model_vertexpos, 1.0);
	NormalizedNormal = vec3(1.0);
	worldPos = vec3(ModelViewMatrix*vec4(model_vertexpos, 1.0));
	
	Normal0 = (ModelMatrix * vec4(model_normalpos, 0.0)).xyz; 
	
    mat4 mvp = ProjectionMatrix * ViewMatrix * ModelMatrix;
    gl_Position = mvp * vec4(model_vertexpos, 1.0);
}

"

uniform sampler2D decalMap;    // Level textures.
uniform sampler2D lightMap;    // Level light map.
uniform sampler2D normalMap;   // Level decal normal map.

uniform sampler2D depthMap;	
/*
struct Light {
	vec3 diffuse;
	vec3 position;
	float dotSize;
};*/

struct BaseLight                                                                    
{                                                                                   
    vec3 Color;                                                                     
    float AmbientIntensity;                                                         
    float DiffuseIntensity;                                                         
};                                                                                  
                                                                                    
struct DirectionalLight                                                             
{                                                                                   
    BaseLight Base;                                                                 
    vec3 Direction;                                                                 
};                                                                                  
                                                                                    
struct Attenuation                                                                  
{                                                                                   
    float Constant;                                                                 
    float Linear;                                                                   
    float Exp;                                                                      
};                                                                                  
                                                                                    
struct PointLight                                                                           
{                                                                                           
    BaseLight Base;                                                                         
    vec3 Position;                                                                          
    Attenuation Atten;                                                                      
};                                                                                          
  
int gNumPointLights = 2;                                                                
uniform DirectionalLight gDirectionalLight;                                                 
uniform PointLight gPointLights[3];                                                                                                      
float gMatSpecularIntensity = .9;                                                        
float gSpecularPower = .7;

//uniform Light lights[3];

uniform vec3 cameraPos;

in vec3 Normal0;   

in vec2 decal_pos;      
in vec2 light_pos;

layout(location = 0) out vec4 color;

in vec4 ModelViewMatrix;
in vec3 NormalizedNormal;
in vec3 worldPos;

#define PI  3.14159265

/*
float scatterAmount = 0.06;

float atanR(float x) {
   return PI*0.5*x / (1.0+x);
}

float Scatter(vec3 vPos, vec3 lPos, float dotSize) {
	float d = length(vPos/dotSize);
	vPos /= d;

	vec3 q = -lPos;

	float b = dot(vPos, q);
	float c = dot(q, q);

	float s = 1.0/sqrt(c-b*b);

	float l = s*(atan((d+b)*s)-atan(b*s));

	return l;
}

vec3 LinearToSrgb(vec3 rgb) {
	return pow(rgb, vec3(1.0/2.2));
}

float phong(vec3 worldPos, vec3 normal, vec3 lightPos, float spec) {
	vec3 l = lightPos-worldPos;
	float d = length(l);
	l /= d;

	vec3 h = normalize(l);
	
	float diffuse = clamp(dot(normal, l),0.0,1.0) / (d*d*2.0);
	float specular = pow(clamp(dot(h,normal),0.0,1.0), spec)/ (d);
    return diffuse+(specular);
}
*/


vec4 CalcLightInternal(BaseLight Light, vec3 LightDirection, vec3 Normal)                   
{                                                                                           
    vec4 AmbientColor = vec4(Light.Color, 1.0f) * Light.AmbientIntensity;                   
    float DiffuseFactor = dot(Normal, -LightDirection);                                     
    vec4 DiffuseColor  = vec4(0, 0, 0, 0);                                                  
    vec4 SpecularColor = vec4(0, 0, 0, 0);                                                  
                                                                                            
    if (DiffuseFactor > 0) {                                                                
        DiffuseColor = vec4(Light.Color, 1.0f) * Light.DiffuseIntensity * DiffuseFactor;    
                                                                                            
        vec3 VertexToEye = normalize(cameraPos - worldPos);                             
        vec3 LightReflect = normalize(reflect(LightDirection, Normal));                     
        float SpecularFactor = dot(VertexToEye, LightReflect);                              
        SpecularFactor = pow(SpecularFactor, gSpecularPower);                               
        if (SpecularFactor > 0) {                                                           
            SpecularColor = vec4(Light.Color, 1.0f) *                                       
                            gMatSpecularIntensity * SpecularFactor;                         
        }                                                                                   
    }                                                                                       
                                                                                           
    return (AmbientColor + DiffuseColor + SpecularColor);                                   
} 

                                                                                            
vec4 CalcDirectionalLight(vec3 n)                                                      
{                                                                                           
    return CalcLightInternal(gDirectionalLight.Base, gDirectionalLight.Direction, n); 
}                                                                                           
                                                                                            
vec4 CalcPointLight(int Index, vec3 Normal)                                                 
{                                                                                           
    vec3 LightDirection = ModelViewMatrix.xyz - gPointLights[Index].Position;                         
    float Distance = length(LightDirection);                                                
    LightDirection = normalize(LightDirection);                                             
                                                                                            
    vec4 Colors = CalcLightInternal(gPointLights[Index].Base, LightDirection, Normal);       
    float sas =  gPointLights[Index].Atten.Constant +                               
                         gPointLights[Index].Atten.Linear * Distance +                      
                         gPointLights[Index].Atten.Exp * Distance * Distance;               
                                                                                            
    return Colors / sas;//vec4(Colors.r/sas, Colors.g/sas, Colors.b/sas, Colors.a/sas);                                                          
}                                                                                           
   

void main() {
	vec3 worldPos = ModelViewMatrix.xyz;
    vec3 normalPos = NormalizedNormal.xyz;

	vec3 ct, cf, c;
  	vec4 texel;
  	
  	float intensity, at, af, a;
  	vec3 lightDir = vec3(0.0f);
  	vec3 normal = vec3(0.0f);
  	
  	intensity = -0.5f;
  	
    vec3 scatter = vec3(0.0);
    vec3 light = vec3(0.0);
    
	float coefA = smoothstep( 1.0, 0.2, intensity );
  	
  	vec3 Normala = normalize(Normal0);                                                       
    vec4 TotalLight = vec4(0.0);//CalcDirectionalLight(Normala);                                         
                                                                                            
    for ( int i = 0 ; i < gNumPointLights; i++ ) {                       
        TotalLight += coefA * CalcPointLight(i, Normala);                                          
    }                                                                                       
                    
  	light += coefA * vec3(texture(lightMap, light_pos));
  	cf = vec3( intensity );

	texel = texture( decalMap, decal_pos );
  	
 	ct = texel.rgb;
  	at = texel.a;

  	c = cf * ct;
  	a = at;  
  
  	float fog = clamp( 25.0, 0.0, 1.0 );
  	float coef = smoothstep( 1.0, 0.2, -0.5 );

  	c += coef * vec3(texture(lightMap, light_pos));
	
    vec3 _normal = texture(normalMap, decal_pos).rgb;

    vec3 N = normalize(_normal * 2.0 - 1.0);
    light += coef * TotalLight.rgb;
    vec3 L = normalize(light);

	float nDotL = dot(N, L);
	vec3 normalVector = vec3(_normal - vec3(0.5));
 	normalVector = normalize(normalVector);
  
	vec3 reflection = normalVector;
    reflection = reflection * nDotL * 2.0;
    reflection -= L;
    float specIntensity = pow( dot( reflection, vec3(0.0, 0.0, 1.0) ), 100.6 );

	vec3 scatter_decal = (vec3(texture(decalMap, decal_pos))  ) / 2.5;
	vec3 Diffuse = (scatter_decal * a) * max(dot(N, L), 0.0) + (light/2.1*coefA) + (TotalLight.rgb/1.7);

	//Diffuse += finalSpec;
    float fogA = clamp( distance(worldPos, cameraPos) / 2500.0, 0.0, 1.0 );
    
    vec3 lights = Diffuse * (light + specIntensity);
 
    color = vec4( lights, 1.0 );
}
"